{"version":3,"sources":["rekord-migrations.min.js"],"names":["root","factory","define","amd","Rekord","module","exports","global","require","this","undefined","ApplicationMigrator","name","dependents","stores","datas","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","migrationLog","migrationLogs","Array","prototype","slice","call","arguments","Model","Collection","Promise","Events","Class","isArray","isObject","toArray","isFunction","copy","isEmpty","noop","indexOf","propsMatch","create","creator","valid","requireNotExists","created","migrationTest","drop","requireExists","dropping","clear","rename","fromName","toName","fromDatas","moveRelatedOut","field","intoName","intoDatas","i","record","related","addAll","add","moveRelatedIn","fromKey","intoKey","many","totalRelated","where","fromModel","migratorCallback","migrator","result","newRecord","props","status","$saved","$status","Status","Synced","exists","empty","fieldInput","fields","transform","removeField","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","console","log","Function","unshift","apply","MigrationsTested","onNormalLoadProcedure","modelStore","modelData","modelKeys","modelClass","modelDatabase","keyHandler","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["/* rekord-migrations 1.5.0 - Migrations for rekord by Philip Diffenderfer */\n// UMD (Universal Module Definition)\n(function (root, factory)\n{\n  if (typeof define === 'function' && define.amd) // jshint ignore:line\n  {\n    // AMD. Register as an anonymous module.\n    define(['rekord'], function(Rekord) { // jshint ignore:line\n      return factory(root, Rekord);\n    });\n  }\n  else if (typeof module === 'object' && module.exports)  // jshint ignore:line\n  {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(global, require('rekord'));  // jshint ignore:line\n  }\n  else\n  {\n    // Browser globals (root is window)\n    root.Rekord = factory(root, root.Rekord);\n  }\n}(this, function(global, Rekord, undefined)\n{\n\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n  var Class = Rekord.Class;\n\n  var isArray = Rekord.isArray;\n  var isObject = Rekord.isObject;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n  var propsMatch = Rekord.propsMatch;\n\nfunction ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nClass.create( ApplicationMigrator,\n{\n  create: function(name, creator)\n  {\n    var valid = this.requireNotExists( name );\n\n    if ( valid )\n    {\n      var created = this.datas[ name ] = new Collection( creator() );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'new store ' + name + ' created  (' + created.length + ' records)', created );\n      }\n    }\n  },\n\n  drop: function(name)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var dropping = this.datas[ name ];\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' dropped (' + dropping.length + ' records)', dropping.slice() );\n      }\n\n      dropping.clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( toName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n\n      this.datas[ toName ] = fromDatas;\n      this.datas[ fromName ] = new Collection();\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' renamed to ' + toName + ' (' + fromDatas.length + ' records)', fromDatas );\n      }\n    }\n  },\n\n  moveRelatedOut: function(fromName, field, intoName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n\n      for (var i = 0; i < fromDatas.length; i++)\n      {\n        var record = fromDatas[ i ];\n        var related = record[ field ];\n\n        if ( isArray( related ) )\n        {\n          intoDatas.addAll( related );\n        }\n        else if ( isObject( related ) )\n        {\n          intoDatas.add( related );\n        }\n\n        delete record[ field ];\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + intoName + ' populated from the records located in the ' + field + ' property of the ' + fromName + ' store (' + intoDatas.length + ' records)', intoDatas );\n      }\n    }\n  },\n\n  moveRelatedIn: function(fromName, fromKey, intoName, intoKey, field, many)\n  {\n    var valid = this.requireExists( fromName ) && this.requireExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n      var totalRelated = 0;\n\n      for (var i = 0; i < intoDatas.length; i++)\n      {\n        var record = intoDatas[ i ];\n        var related = fromDatas.where(function(fromModel) // jshint ignore:line\n        {\n          return propsMatch(fromModel, fromKey, record, intoKey);\n        });\n\n        record[ field ] = many ? related : related[0];\n        totalRelated += related.length;\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' moved into ' + intoName + ' to property ' + field + ' (' + totalRelated + ' matched, ' + (fromDatas.length - totalRelated) + ' unmatched)', fromDatas.slice() );\n      }\n\n      fromDatas.clear();\n    }\n  },\n\n  migrate: function(name, migratorCallback)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var migrator = new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration start', migrator );\n      }\n\n      var result = migratorCallback.call( migrator, migrator );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration end', migrator );\n      }\n\n      return result;\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' exists in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n    }\n\n    return exists;\n  },\n\n  requireNotExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n    var empty = this.datas[ name ].length === 0;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' does not exist yet in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists && empty );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( !empty )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but existing data was found';\n      }\n    }\n\n    return exists && empty;\n  }\n});\n\nfunction ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nClass.create( ModelMigrator,\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'dropping fields', fields );\n    }\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with dynamic default value: ' + defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with constant default value', defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'renaming field from ' + oldField + ' to ' + newField );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'converting field ' + field + ': ' + converter );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'filtering records: ' + filter );\n    }\n\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'remove field ' + field + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'remove field ' + field + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'running transform: ' + transformer );\n    }\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          if ( Rekord.migrationTest )\n          {\n            migrationLog( 'removing record', record );\n          }\n\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n});\n\n\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations loaded', migrations );\n    }\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations being ran', MigrationMap );\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store loaded', datas[ modelName ] );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        if ( Rekord.migrationTest )\n        {\n          migrationLog( 'running migration ' + definition.name, migrator );\n        }\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.keyHandler.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      var console = global.console;\n\n      if ( console && console.log )\n      {\n        var log = console.log;\n        var call = Function.prototype.call;\n\n        for (var i = 0; i < migrationLogs.length; i++)\n        {\n          migrationLogs[ i ].unshift( console );\n\n          call.apply( log, migrationLogs[ i ] );\n        }\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n\n\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n\nfunction migrationLog()\n{\n  migrationLogs.push( Array.prototype.slice.call( arguments ) );\n}\n\n\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.migrationLogs = migrationLogs;\n\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n  return Rekord;\n\n}));\n"],"sourceRoot":"/source/"}