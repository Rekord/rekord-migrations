{"version":3,"sources":["rekord-migrations.min.js"],"names":["root","factory","define","amd","Rekord","module","exports","global","require","this","undefined","ApplicationMigrator","name","dependents","stores","datas","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","migrationLog","migrationLogs","Array","prototype","slice","call","arguments","Model","Collection","Promise","Events","isArray","isObject","toArray","isFunction","copy","isEmpty","noop","indexOf","propsMatch","create","creator","valid","requireNotExists","created","migrationTest","drop","requireExists","dropping","clear","rename","fromName","toName","fromDatas","moveRelatedOut","field","intoName","intoDatas","i","record","related","addAll","add","moveRelatedIn","fromKey","intoKey","many","totalRelated","where","fromModel","migratorCallback","migrator","result","newRecord","props","status","$saved","$status","Status","Synced","exists","empty","fieldInput","fields","transform","removeField","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","console","log","Function","unshift","apply","MigrationsTested","onNormalLoadProcedure","modelStore","modelData","modelKeys","modelClass","modelDatabase","keyHandler","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["/* rekord-migrations 1.4.3 - Migrations for rekord by Philip Diffenderfer */\n// UMD (Universal Module Definition)\n(function (root, factory)\n{\n  if (typeof define === 'function' && define.amd) // jshint ignore:line\n  {\n    // AMD. Register as an anonymous module.\n    define(['rekord'], function(Rekord) { // jshint ignore:line\n      return factory(root, Rekord);\n    });\n  }\n  else if (typeof module === 'object' && module.exports)  // jshint ignore:line\n  {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(global, require('rekord'));  // jshint ignore:line\n  }\n  else\n  {\n    // Browser globals (root is window)\n    root.Rekord = factory(root, root.Rekord);\n  }\n}(this, function(global, Rekord, undefined)\n{\n\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n\n  var isArray = Rekord.isArray;\n  var isObject = Rekord.isObject;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n  var propsMatch = Rekord.propsMatch;\n\nfunction ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nApplicationMigrator.prototype =\n{\n  create: function(name, creator)\n  {\n    var valid = this.requireNotExists( name );\n\n    if ( valid )\n    {\n      var created = this.datas[ name ] = new Collection( creator() );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'new store ' + name + ' created  (' + created.length + ' records)', created );\n      }\n    }\n  },\n\n  drop: function(name)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var dropping = this.datas[ name ];\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' dropped (' + dropping.length + ' records)', dropping.slice() );\n      }\n\n      dropping.clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( toName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n\n      this.datas[ toName ] = fromDatas;\n      this.datas[ fromName ] = new Collection();\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' renamed to ' + toName + ' (' + fromDatas.length + ' records)', fromDatas );\n      }\n    }\n  },\n\n  moveRelatedOut: function(fromName, field, intoName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n\n      for (var i = 0; i < fromDatas.length; i++)\n      {\n        var record = fromDatas[ i ];\n        var related = record[ field ];\n\n        if ( isArray( related ) )\n        {\n          intoDatas.addAll( related );\n        }\n        else if ( isObject( related ) )\n        {\n          intoDatas.add( related );\n        }\n\n        delete record[ field ];\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + intoName + ' populated from the records located in the ' + field + ' property of the ' + fromName + ' store (' + intoDatas.length + ' records)', intoDatas );\n      }\n    }\n  },\n\n  moveRelatedIn: function(fromName, fromKey, intoName, intoKey, field, many)\n  {\n    var valid = this.requireExists( fromName ) && this.requireExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n      var totalRelated = 0;\n\n      for (var i = 0; i < intoDatas.length; i++)\n      {\n        var record = intoDatas[ i ];\n        var related = fromDatas.where(function(fromModel) // jshint ignore:line\n        {\n          return propsMatch(fromModel, fromKey, record, intoKey);\n        });\n\n        record[ field ] = many ? related : related[0];\n        totalRelated += related.length;\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' moved into ' + intoName + ' to property ' + field + ' (' + totalRelated + ' matched, ' + (fromDatas.length - totalRelated) + ' unmatched)', fromDatas.slice() );\n      }\n\n      fromDatas.clear();\n    }\n  },\n\n  migrate: function(name, migratorCallback)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var migrator = new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration start', migrator );\n      }\n\n      var result = migratorCallback.call( migrator, migrator );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration end', migrator );\n      }\n\n      return result;\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' exists in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n    }\n\n    return exists;\n  },\n\n  requireNotExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n    var empty = this.datas[ name ].length === 0;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' does not exist yet in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists && empty );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( !empty )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but existing data was found';\n      }\n    }\n\n    return exists && empty;\n  }\n};\n\nfunction ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nModelMigrator.prototype =\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'dropping fields', fields );\n    }\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with dynamic default value: ' + defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with constant default value', defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'renaming field from ' + oldField + ' to ' + newField );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'converting field ' + field + ': ' + converter );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'filtering records: ' + filter );\n    }\n\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'remove field ' + field + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'remove field ' + field + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'running transform: ' + transformer );\n    }\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          if ( Rekord.migrationTest )\n          {\n            migrationLog( 'removing record', record );\n          }\n\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n};\n\n\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations loaded', migrations );\n    }\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations being ran', MigrationMap );\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store loaded', datas[ modelName ] );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        if ( Rekord.migrationTest )\n        {\n          migrationLog( 'running migration ' + definition.name, migrator );\n        }\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.keyHandler.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      var console = global.console;\n\n      if ( console && console.log )\n      {\n        var log = console.log;\n        var call = Function.prototype.call;\n\n        for (var i = 0; i < migrationLogs.length; i++)\n        {\n          migrationLogs[ i ].unshift( console );\n\n          call.apply( log, migrationLogs[ i ] );\n        }\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n\n\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n\nfunction migrationLog()\n{\n  migrationLogs.push( Array.prototype.slice.call( arguments ) );\n}\n\n\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.migrationLogs = migrationLogs;\n\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n  return Rekord;\n\n}));\n"],"sourceRoot":"/source/"}