{"version":3,"sources":["header.js","ApplicationMigrator.js","ModelMigrator.js","migration.js","load.js","footer.js"],"names":["global","Rekord","undefined","ApplicationMigrator","name","dependents","stores","datas","this","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","migrationLog","migrationLogs","Array","prototype","slice","call","arguments","Model","Collection","Promise","Events","isArray","isObject","toArray","isFunction","copy","isEmpty","noop","indexOf","propsMatch","create","creator","requireNotExists","created","migrationTest","drop","requireExists","dropping","clear","rename","fromName","toName","fromDatas","moveRelatedOut","field","intoName","intoDatas","i","record","related","addAll","add","moveRelatedIn","fromKey","intoKey","many","totalRelated","where","fromModel","migratorCallback","migrator","result","newRecord","props","status","$saved","$status","Status","Synced","fieldInput","fields","transform","removeField","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","console","log","Function","unshift","apply","MigrationsTested","onNormalLoadProcedure","modelStore","modelData","modelKeys","modelClass","modelDatabase","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["(function(global, Rekord, undefined)\n{\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n\n  var isArray = Rekord.isArray;\n  var isObject = Rekord.isObject;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n  var propsMatch = Rekord.propsMatch;\n","function ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nApplicationMigrator.prototype =\n{\n  create: function(name, creator)\n  {\n    this.requireNotExists( name );\n\n    var created = this.datas[ name ] = new Collection( creator() );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'new store ' + name + ' created  (' + created.length + ' records)', created );\n    }\n  },\n\n  drop: function(name)\n  {\n    this.requireExists( name );\n\n    var dropping = this.datas[ name ];\n\n    if ( dropping )\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' dropped (' + dropping.length + ' records)', dropping.slice() );\n      }\n\n      dropping.clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    this.requireExists( fromName );\n    this.requireNotExists( toName );\n\n    var fromDatas = this.datas[ fromName ];\n\n    if ( fromDatas )\n    {\n      this.datas[ toName ] = fromDatas;\n      this.datas[ fromName ] = new Collection();\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' renamed to ' + toName + ' (' + fromDatas.length + ' records)', fromDatas );\n      }\n    }\n  },\n\n  moveRelatedOut: function(fromName, field, intoName)\n  {\n    this.requireExists( fromName );\n    this.requireNotExists( intoName );\n\n    var fromDatas = this.datas[ fromName ];\n    var intoDatas = this.datas[ intoName ];\n\n    if ( fromDatas && intoDatas )\n    {\n      for (var i = 0; i < fromDatas.length; i++)\n      {\n        var record = fromDatas[ i ];\n        var related = record[ field ];\n\n        if ( isArray( related ) )\n        {\n          intoDatas.addAll( related );\n        }\n        else if ( isObject( related ) )\n        {\n          intoDatas.add( related );\n        }\n\n        delete record[ field ];\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + intoName + ' populated from the records located in the ' + field + ' property of the ' + fromName + ' store (' + intoDatas.length + ' records)', intoDatas );\n      }\n    }\n  },\n\n  moveRelatedIn: function(fromName, fromKey, intoName, intoKey, field, many)\n  {\n    this.requireExists( fromName );\n    this.requireExists( intoName );\n\n    var fromDatas = this.datas[ fromName ];\n    var intoDatas = this.datas[ intoName ];\n    var totalRelated = 0;\n\n    if ( fromDatas && intoDatas )\n    {\n      for (var i = 0; i < intoDatas.length; i++)\n      {\n        var record = intoDatas[ i ];\n        var related = fromDatas.where(function(fromModel)\n        {\n          return propsMatch(fromModel, fromKey, record, intoKey);\n        });\n\n        record[ field ] = many ? related : related[0];\n        totalRelated += related.length;\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' moved into ' + intoName + ' to property ' + field + ' (' + totalRelated + ' matched, ' + (fromDatas.length - totalRelated) + ' unmatched)', fromDatas.slice() );\n      }\n\n      fromDatas.clear();\n    }\n  },\n\n  migrate: function(name, migratorCallback)\n  {\n    this.requireExists( name );\n\n    if ( name in this.stores )\n    {\n      var migrator = new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration start', migrator );\n      }\n\n      var result = migratorCallback.call( migrator, migrator );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration end', migrator );\n      }\n\n      return result;\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' exists in ' + (this.safe ? 'safe' : 'strict') + ' mode', indexOf( this.dependents, name ) !== false );\n    }\n\n    if ( !this.safe )\n    {\n      if ( indexOf( this.dependents, name ) === false )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n    }\n  },\n\n  requireNotExists: function(name)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' does not exist yet in ' + (this.safe ? 'safe' : 'strict') + ' mode', indexOf( this.dependents, name ) !== false && this.datas[ name ].length === 0 );\n    }\n\n    if ( !this.safe )\n    {\n      if ( indexOf( this.dependents, name ) === false )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( this.datas[ name ].length !== 0 )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but existing data was found';\n      }\n    }\n  }\n};\n","function ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nModelMigrator.prototype =\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'dropping fields', fields );\n    }\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with dynamic default value: ' + defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with constant default value', defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'renaming field from ' + oldField + ' to ' + newField );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'converting field ' + field + ': ' + converter );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'filtering records: ' + filter );\n    }\n\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'remove field ' + field + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'remove field ' + field + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'running transform: ' + transformer );\n    }\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          if ( Rekord.migrationTest )\n          {\n            migrationLog( 'removing record', record );\n          }\n\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n};\n","\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n\nfunction migrationLog()\n{\n  migrationLogs.push( Array.prototype.slice.call( arguments ) );\n}\n","\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = Rekord.loadPromise || new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations loaded', migrations );\n    }\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations being ran', MigrationMap );\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store loaded', datas[ modelName ] );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        if ( Rekord.migrationTest )\n        {\n          migrationLog( 'running migration ' + definition.name, migrator );\n        }\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      var console = global.console;\n\n      if ( console && console.log )\n      {\n        var log = console.log;\n        var call = Function.prototype.call;\n\n        for (var i = 0; i < migrationLogs.length; i++)\n        {\n          migrationLogs[ i ].unshift( console );\n\n          call.apply( log, migrationLogs[ i ] );\n        }\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n","\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.migrationLogs = migrationLogs;\n\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n})(this, Rekord);\n"],"sourceRoot":"/source/"}