{"version":3,"sources":["rekord-migrations.min.js"],"names":["global","Rekord","undefined","ApplicationMigrator","name","dependents","stores","datas","this","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","migrationLog","migrationLogs","Array","prototype","slice","call","arguments","Model","Collection","Promise","Events","isArray","isObject","toArray","isFunction","copy","isEmpty","noop","indexOf","propsMatch","create","creator","valid","requireNotExists","created","migrationTest","drop","requireExists","dropping","clear","rename","fromName","toName","fromDatas","moveRelatedOut","field","intoName","intoDatas","i","record","related","addAll","add","moveRelatedIn","fromKey","intoKey","many","totalRelated","where","fromModel","migratorCallback","migrator","result","newRecord","props","status","$saved","$status","Status","Synced","exists","empty","fieldInput","fields","transform","removeField","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","console","log","Function","unshift","apply","MigrationsTested","onNormalLoadProcedure","modelStore","modelData","modelKeys","modelClass","modelDatabase","keyHandler","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["/* rekord-migrations 1.4.1 - Migrations for rekord by Philip Diffenderfer */\n(function(global, Rekord, undefined)\n{\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n\n  var isArray = Rekord.isArray;\n  var isObject = Rekord.isObject;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n  var propsMatch = Rekord.propsMatch;\n\nfunction ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nApplicationMigrator.prototype =\n{\n  create: function(name, creator)\n  {\n    var valid = this.requireNotExists( name );\n\n    if ( valid )\n    {\n      var created = this.datas[ name ] = new Collection( creator() );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'new store ' + name + ' created  (' + created.length + ' records)', created );\n      }\n    }\n  },\n\n  drop: function(name)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var dropping = this.datas[ name ];\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' dropped (' + dropping.length + ' records)', dropping.slice() );\n      }\n\n      dropping.clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( toName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n\n      this.datas[ toName ] = fromDatas;\n      this.datas[ fromName ] = new Collection();\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' renamed to ' + toName + ' (' + fromDatas.length + ' records)', fromDatas );\n      }\n    }\n  },\n\n  moveRelatedOut: function(fromName, field, intoName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n\n      for (var i = 0; i < fromDatas.length; i++)\n      {\n        var record = fromDatas[ i ];\n        var related = record[ field ];\n\n        if ( isArray( related ) )\n        {\n          intoDatas.addAll( related );\n        }\n        else if ( isObject( related ) )\n        {\n          intoDatas.add( related );\n        }\n\n        delete record[ field ];\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + intoName + ' populated from the records located in the ' + field + ' property of the ' + fromName + ' store (' + intoDatas.length + ' records)', intoDatas );\n      }\n    }\n  },\n\n  moveRelatedIn: function(fromName, fromKey, intoName, intoKey, field, many)\n  {\n    var valid = this.requireExists( fromName ) && this.requireExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n      var totalRelated = 0;\n\n      for (var i = 0; i < intoDatas.length; i++)\n      {\n        var record = intoDatas[ i ];\n        var related = fromDatas.where(function(fromModel) // jshint ignore:line\n        {\n          return propsMatch(fromModel, fromKey, record, intoKey);\n        });\n\n        record[ field ] = many ? related : related[0];\n        totalRelated += related.length;\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' moved into ' + intoName + ' to property ' + field + ' (' + totalRelated + ' matched, ' + (fromDatas.length - totalRelated) + ' unmatched)', fromDatas.slice() );\n      }\n\n      fromDatas.clear();\n    }\n  },\n\n  migrate: function(name, migratorCallback)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var migrator = new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration start', migrator );\n      }\n\n      var result = migratorCallback.call( migrator, migrator );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration end', migrator );\n      }\n\n      return result;\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' exists in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n    }\n\n    return exists;\n  },\n\n  requireNotExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n    var empty = this.datas[ name ].length === 0;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' does not exist yet in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists && empty );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( !empty )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but existing data was found';\n      }\n    }\n\n    return exists && empty;\n  }\n};\n\nfunction ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nModelMigrator.prototype =\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'dropping fields', fields );\n    }\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with dynamic default value: ' + defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with constant default value', defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'renaming field from ' + oldField + ' to ' + newField );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'converting field ' + field + ': ' + converter );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'filtering records: ' + filter );\n    }\n\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'remove field ' + field + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'remove field ' + field + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'running transform: ' + transformer );\n    }\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          if ( Rekord.migrationTest )\n          {\n            migrationLog( 'removing record', record );\n          }\n\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n};\n\n\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations loaded', migrations );\n    }\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations being ran', MigrationMap );\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store loaded', datas[ modelName ] );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        if ( Rekord.migrationTest )\n        {\n          migrationLog( 'running migration ' + definition.name, migrator );\n        }\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.keyHandler.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      var console = global.console;\n\n      if ( console && console.log )\n      {\n        var log = console.log;\n        var call = Function.prototype.call;\n\n        for (var i = 0; i < migrationLogs.length; i++)\n        {\n          migrationLogs[ i ].unshift( console );\n\n          call.apply( log, migrationLogs[ i ] );\n        }\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n\n\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n\nfunction migrationLog()\n{\n  migrationLogs.push( Array.prototype.slice.call( arguments ) );\n}\n\n\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.migrationLogs = migrationLogs;\n\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n})(this, this.Rekord);\n"],"sourceRoot":"/source/"}