{"version":3,"sources":["header.js","ApplicationMigrator.js","ModelMigrator.js","migration.js","load.js","footer.js"],"names":["global","Rekord","undefined","ApplicationMigrator","name","dependents","stores","datas","this","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","Model","Collection","Promise","Events","isArray","isObject","toArray","isFunction","copy","isEmpty","noop","indexOf","propsMatch","prototype","create","creator","requireNotExists","drop","requireExists","clear","rename","fromName","toName","moveRelatedOut","field","intoName","fromDatas","intoDatas","i","record","related","addAll","add","moveRelatedIn","fromKey","intoKey","many","where","fromModel","migratorCallback","migrator","call","newRecord","props","status","$saved","$status","Status","Synced","fieldInput","fields","transform","removeField","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","result","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","migrationTest","console","log","migrationLogs","MigrationsTested","modelStore","modelData","modelKeys","modelClass","modelDatabase","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onNormalLoadProcedure","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded","slice"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["(function(global, Rekord, undefined)\n{\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n\n  var isArray = Rekord.isArray;\n  var isObject = Rekord.isObject;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n  var propsMatch = Rekord.propsMatch;\n","function ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nApplicationMigrator.prototype =\n{\n  create: function(name, creator)\n  {\n    this.requireNotExists( name );\n\n    this.datas[ name ] = new Collection( creator() );\n  },\n\n  drop: function(name)\n  {\n    this.requireExists( name );\n\n    if ( name in this.datas )\n    {\n      this.datas[ name ].clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    this.requireExists( fromName );\n    this.requireNotExists( toName );\n\n    if ( fromName in this.datas )\n    {\n      this.datas[ toName ] = this.datas[ fromName ];\n      this.datas[ fromName ] = new Collection();\n    }\n  },\n\n  moveRelatedOut: function(fromName, field, intoName)\n  {\n    this.requireExists( fromName );\n    this.requireNotExists( intoName );\n\n    var fromDatas = this.datas[ fromName ];\n    var intoDatas = this.datas[ intoName ];\n\n    for (var i = 0; i < fromDatas.length; i++)\n    {\n      var record = fromDatas[ i ];\n      var related = record[ field ];\n\n      if ( isArray( related ) )\n      {\n        intoDatas.addAll( related );\n      }\n      else if ( isObject( related ) )\n      {\n        intoDatas.add( related );\n      }\n\n      delete record[ field ];\n    }\n  },\n\n  moveRelatedIn: function(fromName, fromKey, intoName, intoKey, field, many)\n  {\n    this.requireExists( fromName );\n    this.requireExists( intoName );\n\n    var fromDatas = this.datas[ fromName ];\n    var intoDatas = this.datas[ intoName ];\n\n    for (var i = 0; i < intoDatas.length; i++)\n    {\n      var record = intoDatas[ i ];\n      var related = fromDatas.where(function(fromModel)\n      {\n        return propsMatch(fromModel, fromKey, record, intoKey);\n      });\n\n      record[ field ] = many ? related : related[0];\n    }\n\n    fromDatas.clear();\n  },\n\n  migrate: function(name, migratorCallback)\n  {\n    this.requireExists( name );\n\n    if ( name in this.stores )\n    {\n      var migrator = new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] );\n\n      return migratorCallback.call( migrator, migrator );\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    if ( !this.safe )\n    {\n      if ( indexOf( this.dependents, name ) === false )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( !(name in this.stores) )\n      {\n        throw 'A migration for ' + name + ' was attempted but does not exist locally (or was not defined)';\n      }\n    }\n  },\n\n  requireNotExists: function(name)\n  {\n    if ( !this.safe )\n    {\n      if ( indexOf( this.dependents, name ) === false )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      /* A store should exist - since they have a Rekord definition\n      if ( name in this.stores )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but already exists';\n      }\n      */\n    }\n  }\n};\n","function ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nModelMigrator.prototype =\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n};\n","\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n","\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = Rekord.loadPromise || new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      if ( global.console && global.console.log )\n      {\n        global.console.log( migrationLogs );\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n","\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n})(this, Rekord);\n"],"sourceRoot":"/source/"}