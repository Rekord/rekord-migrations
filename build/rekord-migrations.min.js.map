{"version":3,"sources":["header.js","ApplicationMigrator.js","ModelMigrator.js","migration.js","load.js","footer.js"],"names":["global","Rekord","undefined","ApplicationMigrator","name","dependents","stores","datas","this","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","Model","Collection","Promise","Events","isArray","toArray","isFunction","copy","isEmpty","noop","indexOf","prototype","create","creator","requireNotExists","drop","requireExists","clear","rename","fromName","toName","migrator","newRecord","props","status","$saved","$status","Status","Synced","fieldInput","fields","transform","record","i","removeField","add","field","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","result","call","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","migrationTest","console","log","migrationLogs","MigrationsTested","modelStore","modelData","modelKeys","modelClass","modelDatabase","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onNormalLoadProcedure","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded","slice"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["(function(global, Rekord, undefined)\n{\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n\n  var isArray = Rekord.isArray;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n","function ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nApplicationMigrator.prototype =\n{\n  create: function(name, creator)\n  {\n    this.requireNotExists( name );\n\n    this.datas[ name ] = new Collection( creator() );\n  },\n\n  drop: function(name)\n  {\n    this.requireExists( name );\n\n    if ( name in this.datas )\n    {\n      this.datas[ name ].clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    this.requireExists( fromName );\n    this.requireNotExists( toName );\n\n    if ( fromName in this.datas )\n    {\n      this.datas[ toName ] = this.datas[ fromName ];\n      this.datas[ fromName ] = new Collection();\n    }\n  },\n\n  migrate: function(name, migrator)\n  {\n    this.requireExists( name );\n\n    if ( name in this.stores )\n    {\n      return migrator( new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] ) );\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    if ( !this.safe )\n    {\n      if ( indexOf( this.dependents, name ) === false )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( !(name in this.stores) )\n      {\n        throw 'A migration for ' + name + ' was attempted but does not exist locally (or was not defined)';\n      }\n    }\n  },\n\n  requireNotExists: function(name)\n  {\n    if ( !this.safe )\n    {\n      if ( indexOf( this.dependents, name ) === false )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      /* A store should exist - since they have a Rekord definition\n      if ( name in this.stores )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but already exists';\n      }\n      */\n    }\n  }\n};\n","function ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nModelMigrator.prototype =\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n};\n","\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n","\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = Rekord.loadPromise || new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      if ( global.console && global.console.log )\n      {\n        global.console.log( migrationLogs );\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n","\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n})(this, Rekord);\n"],"sourceRoot":"/source/"}