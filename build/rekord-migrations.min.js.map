{"version":3,"sources":["header.js","ApplicationMigrator.js","ModelMigrator.js","migration.js","load.js","footer.js"],"names":["global","Rekord","undefined","ApplicationMigrator","name","dependents","stores","datas","this","safe","ModelMigrator","app","store","data","migrateRemovePending","migration","dependencies","migrate","definition","MigrationMap","Migrations","length","push","migrationsClear","migrationLog","migrationLogs","Array","prototype","slice","call","arguments","Model","Collection","Promise","Events","isArray","isObject","toArray","isFunction","copy","isEmpty","noop","indexOf","propsMatch","create","creator","valid","requireNotExists","created","migrationTest","drop","requireExists","dropping","clear","rename","fromName","toName","fromDatas","moveRelatedOut","field","intoName","intoDatas","i","record","related","addAll","add","moveRelatedIn","fromKey","intoKey","many","totalRelated","where","fromModel","migratorCallback","migrator","result","newRecord","props","status","$saved","$status","Status","Synced","exists","empty","fieldInput","fields","transform","removeField","defaultValue","setField","oldField","newField","convert","converter","filter","value","transformer","RemovePending","splice","load","callback","context","onMigrationsLoaded","migrations","trigger","MigrationsLoaded","migrationsLoaded","migrationName","deps","k","required","modelName","classes","Database","storeCount","handler","handleStoreLoad","all","reset","storesLoaded","onStoresLoaded","MigrationRan","console","log","Function","unshift","apply","MigrationsTested","onNormalLoadProcedure","modelStore","modelData","modelKeys","modelClass","modelDatabase","buildKeyFromInput","onStoreReset","MigrationClassNotFound","migrationStore","put","MigrationsSaved","storesReset","MigrationsFinished","onMigrationsFailed","MigrationsNotLoaded","loading","loadBegin","onLoadFinish","success","db","loadedSuccess","loaded","loadFinish","promise","resolve","loadPromise","unloaded"],"mappings":"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","file":"rekord-migrations.min.js","sourcesContent":["(function(global, Rekord, undefined)\n{\n  var Model = Rekord.Model;\n  var Collection = Rekord.Collection;\n  var Promise = Rekord.Promise;\n  var Events = Rekord.Events;\n\n  var isArray = Rekord.isArray;\n  var isObject = Rekord.isObject;\n  var toArray = Rekord.toArray;\n  var isFunction = Rekord.isFunction;\n  var isEmpty = Rekord.isEmpty;\n\n  var copy = Rekord.copy;\n  var noop = Rekord.noop;\n\n  var indexOf = Rekord.indexOf;\n  var propsMatch = Rekord.propsMatch;\n","function ApplicationMigrator(name, dependents, stores, datas)\n{\n  this.name = name;\n  this.dependents = dependents;\n  this.stores = stores;\n  this.datas = datas;\n  this.safe = false;\n}\n\nApplicationMigrator.prototype =\n{\n  create: function(name, creator)\n  {\n    var valid = this.requireNotExists( name );\n\n    if ( valid )\n    {\n      var created = this.datas[ name ] = new Collection( creator() );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'new store ' + name + ' created  (' + created.length + ' records)', created );\n      }\n    }\n  },\n\n  drop: function(name)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var dropping = this.datas[ name ];\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' dropped (' + dropping.length + ' records)', dropping.slice() );\n      }\n\n      dropping.clear();\n    }\n  },\n\n  rename: function(fromName, toName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( toName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n\n      this.datas[ toName ] = fromDatas;\n      this.datas[ fromName ] = new Collection();\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' renamed to ' + toName + ' (' + fromDatas.length + ' records)', fromDatas );\n      }\n    }\n  },\n\n  moveRelatedOut: function(fromName, field, intoName)\n  {\n    var valid = this.requireExists( fromName ) && this.requireNotExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n\n      for (var i = 0; i < fromDatas.length; i++)\n      {\n        var record = fromDatas[ i ];\n        var related = record[ field ];\n\n        if ( isArray( related ) )\n        {\n          intoDatas.addAll( related );\n        }\n        else if ( isObject( related ) )\n        {\n          intoDatas.add( related );\n        }\n\n        delete record[ field ];\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + intoName + ' populated from the records located in the ' + field + ' property of the ' + fromName + ' store (' + intoDatas.length + ' records)', intoDatas );\n      }\n    }\n  },\n\n  moveRelatedIn: function(fromName, fromKey, intoName, intoKey, field, many)\n  {\n    var valid = this.requireExists( fromName ) && this.requireExists( intoName );\n\n    if ( valid )\n    {\n      var fromDatas = this.datas[ fromName ];\n      var intoDatas = this.datas[ intoName ];\n      var totalRelated = 0;\n\n      for (var i = 0; i < intoDatas.length; i++)\n      {\n        var record = intoDatas[ i ];\n        var related = fromDatas.where(function(fromModel) // jshint ignore:line\n        {\n          return propsMatch(fromModel, fromKey, record, intoKey);\n        });\n\n        record[ field ] = many ? related : related[0];\n        totalRelated += related.length;\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + fromName + ' moved into ' + intoName + ' to property ' + field + ' (' + totalRelated + ' matched, ' + (fromDatas.length - totalRelated) + ' unmatched)', fromDatas.slice() );\n      }\n\n      fromDatas.clear();\n    }\n  },\n\n  migrate: function(name, migratorCallback)\n  {\n    var valid = this.requireExists( name );\n\n    if ( valid )\n    {\n      var migrator = new ModelMigrator( this, name, this.stores[ name ], this.datas[ name ] );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration start', migrator );\n      }\n\n      var result = migratorCallback.call( migrator, migrator );\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store ' + name + ' migration end', migrator );\n      }\n\n      return result;\n    }\n  },\n\n  newRecord: function(props, status)\n  {\n    props.$saved = copy( props );\n    props.$status = status || Model.Status.Synced;\n\n    return props;\n  },\n\n  requireExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' exists in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n    }\n\n    return exists;\n  },\n\n  requireNotExists: function(name)\n  {\n    var exists = indexOf( this.dependents, name ) !== false;\n    var empty = this.datas[ name ].length === 0;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'ensuring store for ' + name + ' does not exist yet in ' + (this.safe ? 'safe' : 'strict') + ' mode', exists && empty );\n    }\n\n    if ( !this.safe )\n    {\n      if ( !exists )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but did not exist in the dependencies array';\n      }\n      if ( !empty )\n      {\n        throw 'A creation migration for ' + name + ' was attempted but existing data was found';\n      }\n    }\n\n    return exists && empty;\n  }\n};\n","function ModelMigrator(app, name, store, data)\n{\n  this.app = app;\n  this.name = name;\n  this.store = store;\n  this.data = data;\n  this.migrateRemovePending = false;\n}\n\nModelMigrator.prototype =\n{\n\n  drop: function(fieldInput)\n  {\n    var fields = toArray( fieldInput );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'dropping fields', fields );\n    }\n\n    return this.transform(function(record)\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        this.removeField( record, fields[ i ] );\n      }\n    });\n  },\n\n  add: function(field, defaultValue)\n  {\n    if ( isFunction( defaultValue ) )\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with dynamic default value: ' + defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, defaultValue( record ) );\n      });\n    }\n    else\n    {\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'adding new field with constant default value', defaultValue );\n      }\n\n      return this.transform(function(record)\n      {\n        this.setField( record, field, copy( defaultValue ) );\n      });\n    }\n  },\n\n  rename: function(oldField, newField)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'renaming field from ' + oldField + ' to ' + newField );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, newField, record[ oldField ] );\n      this.removeField( record, oldField );\n    });\n  },\n\n  convert: function(field, converter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'converting field ' + field + ': ' + converter );\n    }\n\n    return this.transform(function(record)\n    {\n      this.setField( record, field, converter( record[ field ], record ) );\n    });\n  },\n\n  filter: function(filter)\n  {\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'filtering records: ' + filter );\n    }\n\n    return this.transform(function(record)\n    {\n      return !!filter( record );\n    });\n  },\n\n  setField: function(record, field, value)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'set field ' + field + ' to ' + value + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      record.$saved[ field ] = value;\n    }\n\n    record[ field ] = value;\n  },\n\n  removeField: function(record, field)\n  {\n    if ( Rekord.migrationTest )\n    {\n      if (record.$saved)\n      {\n        migrationLog( 'remove field ' + field + ' where saved value was ' + record.$saved[ field ] + ' and stored value was ' + record[ field ], record );\n      }\n      else\n      {\n        migrationLog( 'remove field ' + field + ' where stored value was ' + record[ field ], record );\n      }\n    }\n\n    if (record.$saved)\n    {\n      delete record.$saved[ field ];\n    }\n\n    delete record[ field ];\n  },\n\n  transform: function(transformer)\n  {\n    var data = this.data;\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'running transform: ' + transformer );\n    }\n\n    for (var i = 0; i < data.length; i++)\n    {\n      var record = data[ i ];\n\n      if ( this.migrateRemovePending || record.$status !== Model.Status.RemovePending )\n      {\n        var result = transformer.call( this, record );\n\n        if ( result === false )\n        {\n          if ( Rekord.migrationTest )\n          {\n            migrationLog( 'removing record', record );\n          }\n\n          data.splice( i--, 1 );\n        }\n      }\n    }\n\n    return this;\n  }\n\n};\n","\nvar Migrations = [];\nvar MigrationMap = {};\n\nvar migrationLogs = [];\n\nfunction migration(name, dependencies, migrate)\n{\n  var definition = {\n    name: name,\n    dependencies: dependencies,\n    migrate: migrate\n  };\n\n  MigrationMap[ name ] = Migrations.length;\n  Migrations.push( definition );\n}\n\nfunction migrationsClear()\n{\n  MigrationMap = {};\n  Migrations.length = 0;\n}\n\nfunction migrationLog()\n{\n  migrationLogs.push( Array.prototype.slice.call( arguments ) );\n}\n","\n// override Rekord.load\n// don't run loadBegin & loadFinish until migrations are loaded, compared to given, and given are ran\n\nRekord.load = function(callback, context)\n{\n  var promise = Rekord.loadPromise = new Promise( null, false );\n  var loading = Rekord.unloaded.slice();\n  var loaded = [];\n  var loadedSuccess = [];\n\n  promise.success( callback, context || this );\n\n  Rekord.unloaded.length = 0;\n\n  var migrationStore = Rekord.store( {name: Rekord.migrationStore} );\n  var migrationsLoaded = [];\n  var stores = {};\n  var datas = {};\n  var required = {};\n  var storeCount = 0;\n  var storesLoaded = 0;\n  var storesReset = 0;\n\n  function onMigrationsLoaded(migrations)\n  {\n    Rekord.trigger( Events.MigrationsLoaded, [migrations] );\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations loaded', migrations );\n    }\n\n    // Make available to other functions.\n    migrationsLoaded = migrations;\n\n    // Remove registered migrations that have already ran\n    for (var i = 0; i < migrations.length; i++)\n    {\n      delete MigrationMap[ migrations[ i ] ];\n    }\n\n    if ( Rekord.migrationTest )\n    {\n      migrationLog( 'migrations being ran', MigrationMap );\n    }\n\n    // Gather required stores\n    for (var migrationName in MigrationMap)\n    {\n      var definition = Migrations[ MigrationMap[ migrationName ] ];\n      var deps = definition.dependencies;\n\n      for (var k = 0; k < deps.length; k++)\n      {\n        required[ deps[ k ] ] = true;\n      }\n    }\n\n    // Grab store reference from Rekord - or create one\n    for (var modelName in required)\n    {\n      if ( modelName in Rekord.classes )\n      {\n        stores[ modelName ] = Rekord.classes[ modelName ].Database.store;\n      }\n      else\n      {\n        stores[ modelName ] = Rekord.store( {name: modelName} );\n      }\n\n      datas[ modelName ] = new Collection();\n      storeCount++;\n    }\n\n    // Call all on stores to populated datas with Collection\n    for (var modelName in stores)\n    {\n      var handler = handleStoreLoad( modelName );\n\n      stores[ modelName ].all( handler, handler );\n    }\n  }\n\n  function handleStoreLoad(modelName)\n  {\n    return function onStoreLoad(data)\n    {\n      if ( isArray( data ) )\n      {\n        datas[ modelName ].reset( data );\n      }\n\n      if ( Rekord.migrationTest )\n      {\n        migrationLog( 'store loaded', datas[ modelName ] );\n      }\n\n      if ( ++storesLoaded === storeCount )\n      {\n        onStoresLoaded();\n      }\n    };\n  }\n\n  function onStoresLoaded()\n  {\n    // Iterate over Migrations and for each migration that exists in MigrationMap...\n    for (var i = 0; i < Migrations.length; i++)\n    {\n      var definition = Migrations[ i ];\n\n      if ( definition.name in MigrationMap )\n      {\n        var migrator = new ApplicationMigrator( definition.name,\n          definition.dependencies, stores, datas );\n\n        if ( Rekord.migrationTest )\n        {\n          migrationLog( 'running migration ' + definition.name, migrator );\n        }\n\n        // call migration function passing datas, stores, and new ApplicationMigrator\n        definition.migrate( migrator, datas );\n\n        Rekord.trigger( Events.MigrationRan, [definition.name, migrator] );\n      }\n    }\n\n    // apply changes in datas to the stores if !migrationTest\n    if ( !Rekord.migrationTest )\n    {\n      for (var modelName in stores)\n      {\n        var modelStore = stores[ modelName ];\n        var modelData = datas[ modelName ];\n        var modelKeys = [];\n        var modelClass = Rekord.classes[ modelName ];\n\n        if ( modelClass )\n        {\n          var modelDatabase = modelClass.Database;\n\n          for (var k = 0; k < modelData.length; k++)\n          {\n            modelKeys[ k ] = modelDatabase.buildKeyFromInput( modelData[ k ] );\n          }\n\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else if ( modelData.length === 0 )\n        {\n          modelStore.reset( modelKeys, modelData, onStoreReset, onStoreReset );\n        }\n        else\n        {\n          Rekord.trigger( Events.MigrationClassNotFound, [modelName, modelStore, modelData] );\n\n          onStoreReset();\n        }\n      }\n\n      for (var migrationName in MigrationMap)\n      {\n        migrationStore.put( migrationName, migrationName, noop, noop );\n      }\n\n      Rekord.trigger( Events.MigrationsSaved, [MigrationMap] );\n    }\n    else\n    {\n      var console = global.console;\n\n      if ( console && console.log )\n      {\n        var log = console.log;\n        var call = Function.prototype.call;\n\n        for (var i = 0; i < migrationLogs.length; i++)\n        {\n          migrationLogs[ i ].unshift( console );\n\n          call.apply( log, migrationLogs[ i ] );\n        }\n      }\n\n      Rekord.trigger( Events.MigrationsTested, [migrationLogs] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onStoreReset()\n  {\n    if ( ++storesReset === storeCount )\n    {\n      Rekord.trigger( Events.MigrationsFinished, [] );\n\n      onNormalLoadProcedure();\n    }\n  }\n\n  function onMigrationsFailed()\n  {\n    Rekord.trigger( Events.MigrationsNotLoaded, [] );\n\n    onNormalLoadProcedure();\n  }\n\n  function onNormalLoadProcedure()\n  {\n    // Run all loadBegin\n    for (var i = 0; i < loading.length; i++)\n    {\n      loading[ i ].loadBegin( onLoadFinish );\n    }\n  }\n\n  function onLoadFinish(success, db)\n  {\n    // When all loadBegins are finished, run loadFinish\n    loadedSuccess.push( success );\n    loaded.push( db );\n\n    if ( loaded.length === loading.length )\n    {\n      for (var k = 0; k < loaded.length; k++)\n      {\n        var db = loaded[ k ];\n        var success = loadedSuccess[ k ];\n\n        if ( success )\n        {\n          db.loadFinish();\n        }\n      }\n\n      // When all loadFinishes are finished, promise is resolved\n      promise.reset().resolve();\n    }\n  }\n\n  migrationStore.all( onMigrationsLoaded, onMigrationsFailed );\n\n  return promise;\n};\n","\n  Events.MigrationsLoaded       = 'migrations-loaded';\n  Events.MigrationRan           = 'migration-ran';\n  Events.MigrationClassNotFound = 'migration-class-not-found';\n  Events.MigrationsSaved        = 'migrations-saved';\n  Events.MigrationsTested       = 'migrations-tested';\n  Events.MigrationsNotLoaded    = 'migrations-not-loaded';\n  Events.MigrationsFinished     = 'migrations-finished';\n\n  Rekord.migrationTest = false;\n  Rekord.migrationStore = 'migrations';\n\n  Rekord.migration = migration;\n  Rekord.migrationsClear = migrationsClear;\n  Rekord.migrationLogs = migrationLogs;\n\n  Rekord.Migrations = Migrations;\n\n  Rekord.ApplicationMigrator = ApplicationMigrator;\n  Rekord.ModelMigrator = ModelMigrator;\n\n})(this, this.Rekord);\n"],"sourceRoot":"/source/"}